# AuraCode Memory Systems: A Deep Dive

This document provides a comprehensive guide to the memory systems within the AuraCode framework. Memory is the cornerstone of what makes Aura agents intelligent, contextual, and capable of growth. Understanding how it works is crucial for creating compelling agents and extending the platform.

AuraCode features two distinct, powerful memory architectures that correspond to its two agent types: **NCF (Narrative Context Framing)** and **CEAF (Coherent Emergence Agent Framework)**.

## ðŸ§  Core Concepts: The Building Blocks of Memory

Before diving into the specific systems, it's important to understand the fundamental concepts that apply across the framework.

### The `Memory` Object

The fundamental unit of knowledge is the `Memory` object, defined in `memory_system/memory_models.py`. It's a rich data structure with several key attributes:

| Attribute | Description |
| :--- | :--- |
| `id` | A unique identifier (UUID) for the memory. |
| `content` | The textual content of the memory (e.g., "The user's favorite color is blue"). |
| `memory_type` | A classification of the memory's nature (see NCF Memory Types below). |
| `emotion_score` | A float representing the emotional tone of the memory. |
| `salience` | A float indicating the initial importance of the memory. |
| `decay_factor` | A value that decreases over time, reducing the memory's influence if not accessed. |
| `access_count` | The number of times the memory has been retrieved. |
| `creation_time` | The timestamp when the memory was created. |
| `last_accessed` | The timestamp of the most recent retrieval. |
| `custom_metadata` | A flexible JSON field for storing extra information, like the source of the memory. |
| `embedding` | A vector representation of the content, used for semantic search. |

### Isolation by Design

A critical architectural principle of AuraCode is **memory isolation**. Every agent has its own dedicated memory system. An agent can **never** access the memories of another agent. This ensures privacy, security, and allows each agent to develop a unique, un-contaminated personality.

---

## 1. The NCF Memory System: `MemoryBlossom`

`MemoryBlossom` is the standard, robust, and production-ready memory system used by all NCF agents. It's designed to be both powerful and understandable.

-   **File Location:** `memory_system/memory_blossom.py`

### NCF Memory Types

`MemoryBlossom` organizes memories into different "stores" based on their type. This allows the agent to reason about the *kind* of information it is recalling. The primary types are:

-   **Explicit:** Factual information ("The user's name is Alex").
-   **Emotional:** Memories tied to a strong emotional context ("The user felt frustrated when discussing project deadlines").
-   **Procedural:** Step-by-step instructions or processes ("How to bake a cake").
-   **Flashbulb:** Highly significant, pivotal moments that define a relationship or understanding.
-   **Liminal:** Ambiguous, uncertain, or transitional ideas that are still being formed.
-   **Generative:** Creative insights or novel ideas generated by the agent itself.

### Key Dynamics of `MemoryBlossom`

-   **Salience & Decay:** Memories are not static. A memory's importance (`salience`) is boosted when accessed but slowly fades (`decay_factor`) over time if unused. This mimics how real memory works, keeping relevant information accessible while letting trivial details fade.
-   **Criticality (Edge of Chaos):** Retrieval isn't just about finding the most similar memory. `MemoryBlossom` can operate at the "edge of chaos," balancing structured, coherent memories with novel, unique ones. This is controlled by `temperature`, `coherence_bias`, and `novelty_bias` parameters, allowing for more creative or more logical recall depending on the agent's configuration.
-   **Weighted Retrieval:** When an agent recalls a memory, it performs a semantic search using embeddings. The final score for each candidate memory is a weighted combination of its **semantic similarity** to the query and its **current effective salience**.

---

## 2. Advanced NCF: Adaptive RAG (`EnhancedMemoryBlossom`)

`EnhancedMemoryBlossom` is an optional, more advanced layer built on top of the standard `MemoryBlossom`. It introduces concepts from adaptive systems to make retrieval even more intelligent.

-   **File Location:** `enhanced_memory_system.py`

### How it Works

1.  **Adaptive Concept Clustering:** In addition to the standard memory types, this system groups semantically similar memories into **concept clusters**. For example, it might autonomously create a cluster for "Quantum Physics Discussions" or "User's Project Goals."
2.  **Domain-Aware Retrieval:** When retrieving memories, you can provide a `domain_context` (e.g., "physics," "emotional_support"). The system will prioritize retrieving memories from clusters that have specialized in that domain.
3.  **Performance-Weighted Retrieval:** The system tracks the "performance" of interactions. Memories created during successful or highly-rated conversations are given more weight during retrieval, meaning the agent learns to rely on knowledge that has proven useful in the past.

---

## 3. The CEAF Memory System: `AMA`

The **Adaptive Memory Architecture (AMA)** is the experimental memory core of the CEAF agent. It operates on fundamentally different principles than `MemoryBlossom`.

-   **File Location:** `ceaf_system/AMA.py`

### Key Differences from `MemoryBlossom`

| Feature | `MemoryBlossom` (NCF) | `Adaptive Memory Architecture` (CEAF) |
| :--- | :--- | :--- |
| **Organization** | Memories are placed into pre-defined `memory_type` stores. | Memories are **autonomously clustered** into concepts based on semantic similarity. The system decides how to group information. |
| **Core Unit** | `Memory` object, focused on content and salience. | `MemoryExperience` object, focused on **outcome** and **learning**. |
| **Learning** | Learns by adjusting salience and decay. | Learns by analyzing the **outcome** (`outcome_value`) and **lesson** (`learning_value`) of every experience. |
| **Failure** | A low-salience memory is simply less likely to be recalled. | Failure is a first-class citizen. `MemoryExperience` objects explicitly track failures, which are cataloged by the **LCAM** to prevent future mistakes. |

---

## 4. Biographical Memories & Agent Creation

**Biographical Memories** are the foundational "childhood memories" given to an agent upon its creation. They are the primary mechanism for defining an agent's core personality, beliefs, and starting knowledge.

### How They Are Created

The `prebuilt_agents_system.py` file contains the `PersonalityArchitect`. This system uses a template-based approach:

1.  An **`AgentArchetype`** is chosen (e.g., `PHILOSOPHER`, `CREATIVE`).
2.  This archetype maps to a **`PersonalityMatrix`**, which contains lists of `MemoryTemplate` objects for core beliefs, emotional patterns, etc.
3.  The `create_personality_memories()` method converts these templates into a final list of `Memory` objects, ready to be injected into a new agent.

### How They Are Used

Biographical memories are the key to creating rich agents instantly and are used in several ways via the API:

-   **Creation from Scratch:** The `POST /agents/create/from-biography` endpoint accepts a JSON file containing a `config` block and a `biography` list of memories. This allows a developer to define an agent's entire personality in a single file and upload it.
-   **Enriching Existing Agents:** The `POST /agents/{agent_id}/biography/add` endpoint allows you to add new foundational memories to an agent that has already been created, deepening its personality.
-   **Publishing & Cloning:** When a user publishes their agent to the marketplace, its biographical and learned memories form the basis of the public template. When another user clones that agent, they receive a copy of these foundational memories, ensuring the clone shares the same core personality.

---

## 5. Interacting with Memories via the API

The AuraCode API provides a full suite of endpoints for managing an agent's memory, giving developers and users fine-grained control.

### Reading Memories

-   `GET /agents/{agent_id}/memories`: Browse all memories for an agent. Useful for visualization and debugging. Can be filtered by `memory_type`.
-   `POST /agents/{agent_id}/memories/search`: Perform a powerful semantic search within an agent's memory using a natural language query.
-   `GET /agents/{agent_id}/memories/export`: Export an agent's entire memory bank to JSON or CSV format, perfect for backup or analysis.
-   `GET /agents/{agent_id}/memories/analytics`: Get high-level statistics about the memory, such as emotion distribution and salience breakdown.

### Writing & Modifying Memories

-   `POST /agents/{agent_id}/memories/upload`: Bulk-upload a list of new memories to an agent from a JSON or CSV file.
-   `DELETE /agents/{agent_id}/memories/{memory_id}`: Delete a specific, unwanted memory from an agent.

This powerful and flexible memory architecture is what allows AuraCode agents to be more than just chatbots. They are dynamic entities that learn, evolve, and form unique identities based on their experiences. We encourage you to experiment with these systems to create truly next-generation AI agents.
